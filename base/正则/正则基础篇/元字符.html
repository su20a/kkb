<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
// \ :转义字符
// ^ :以某一个元字符开始
// $ ；以某一个元字符结束
// * ：出现零到多次
// + ：出现一次到多次
// ？：出现零次或一次
// {n} ；出现n次
// {n,} ：出现n到多次
// {n,m} ：出现n到m次
// \n ：匹配一个换行
// \. ：除了换行以外的任意字符
// () ：分组
// x|y : x或y中的一个
// [xyz] : 三者中的一个
// [^xyz] : 除了这三个之外的任何一个字符
// [a-z] : a-z之间的任何一个字符
// [^a-z] : 除了a-z之间的任何一个字符
// \d : 一个0-9之间的数字
// \b : 一个边界符
// \w : 数字，字母，下划线中的任意一个字符
// \s : 匹配一个空格 一个制表符 

/*
在[]中出现的所有字符就是代表字符本身的意思 比如[.] 就代表一个点

*/
//如果想匹配18或 19
var res_1 = /^18|19$/;
// 以上这种写法 会匹配到18，19，但是181，819等也会符合
// 只要以18开头或19结尾都符合要求
var res_2 = /^(18|19)$/;
// 用分组的方式 就可以满足要求，只匹配18或19

//字面量和实例两种方式来创建正则的区别
var age = "一百岁";
// 现在我想吧age变量的值当成正则的一部分来进行匹配
// 此时用字面量的形式是没办法做到的，因为出现的在 /表达式/ 所有都会被当成元字符，所以无法拼接变量
var reg_3 = /^\d+"+age+"\d+$/g;  // 这种拼接是无效的，双引号会被当成元字符
var reg_4 = new RegExp("^\\d+"+age+"\\d+$","g"); // 这种实例的方式就ok了
// 注意在实例中 \d 不能表示数字 需要转义 \\d 才能表示数字

//基于exec实现正则的捕获
// 1 捕获到的结果是null 或者一个数组 第一项: 本次捕获到的内容  其余项：对应小分组本次单独捕获的内容
//    index：当前捕获内容在字符串中的起始索引 input:原始字符串
//    每执行一次exec，只能捕获到一个符合正则规则的，但是默认情况下，我们执行一百遍，获取的永远是第一个匹配到的，其余的捕获不到



















</script>
</html>